UDP와 TCP의 가장 큰 차이는 흐름제어
- TCP에서는 신뢰성없는 IP를 기반으로 신뢰성 있는 데이터의 송수신을 제공하기 위해 흐름제어를 했었음
- 또한 TCP에서는 데이터 송수신 이전, 이후에 거치는 연결설정 및 해제과정도 존재하나 UDP에는 존재하지 않음

UDP의 내부 동작 원리
- 호스트 B를 떠난 패킷이 호스트 A에게 전달되도록 하는 것은 IP의 역할
- UDP 패킷을 호스트 A 내에 존재하는 UDP 소켓 중 하나에게 최종 전달하는 것은 IP의 역할이 아닌, UDP의 역할! 

즉, UDP의 역할 중 가장 중요한 것은 호스트로 수신된 패킷을 PORT 정보를 참조하여 최종 목적지인 UDP 소켓에 전달하는 것

UDP의 효율적 사용
- 압축파일의 경우 파일의 일부만 손실되어도 압축해제가 어렵기 때문에 반드시 TCP 기반으로 송수신이 이뤄져야 함
- 실시간 영상 및 음성과 같이 멀티미디어 데이터의 경우 잠깐의 화면 떨림이나 음성 손실은 넘어갈만 함
  실시간 서비스이므로 속도가 더 중요하기 때문에 UDP 기반으로 송수신이 이뤄져야 함 

UDP를 구현 관점에서 이해하기
1. 서버와 클라이언트가 연결되어 있지 않다.
- UDP에서는 서버와 클라이언트가 연결된 상태로 데이터를 송수신 하지 않으므로, 연결 설정의 과정이 필요없다.
- 연결되어 있지 않으므로 데이터를 전송할 때마다 반드시 목적지 주소 정보를 별도로 추가해주어야 한다
- 따라서 listen, accept 함수 호출 불필요
2. 서버건 클라이언트건 하나의 소켓만 있으면 된다 (편지를 주고받을 땐 우체통이 하나만 필요하듯이)

- 관련 실습 파일: uecho_client.c, uecho_server.c

UDP 데이터 입출력 함수 --------------------------------
1. sendto()
 - UDP 데이터 전송 시 사용하는 함수
 - TCP 기반 출력함수와 가장 비교되는 점은 매번 목적지 주소를 입력해야 한다는 점
 - 성공 시 전송된 바이트 수, 실패 시 -1 반환
 - 데이터의 전송 과정
   Step1. UDP 소켓에 목적지의 IP와 PORT번호 등록
   Step2. 데이터 전송
   Step3. UDP 소켓에 등록된 목적지 정보 삭제
   (connected UDP 소켓의 경우 sendto 호출 시 Step2만 진행됨)
   
#include <sys/socket.h>
ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr* to, socklen_t addrlen);
 * @param sock: 데이터 전송에 사용될 UDP 소켓의 파일 디스크립터 
 * @param *buff: 전송할 데이터를 저장하고 있는 버퍼의 주소 값
 * @param nbytes: 전송할 데이터 크기를 바이트 단위로 전달
 * @param to: 목적지 주소정보를 담고 있는 sockaddr 구조체 변수의 주소 값 전달
 * @param addrlen: 매개변수 to로 전달된 주소 값의 구조체 변수 크기 전달 

2. recvfrom()
- UDP 데이터 수신에 사용되는 함수
- 발신지가 일정하지 않기 때문에 발신지 정보를 얻을 수 있도록 from 매개변수가 존재
- UDP 패킷에 담겨있는 발신지 정보를 함께 반환
- 성공 시 수신한 바이트 수, 실패 시 -1 반환

#include <sys/socket.h>
ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);
 * @param sock: 데이터 전송에 사용될 UDP 소켓의 파일 디스크립터 
 * @param *buff: 전송할 데이터를 저장하고 있는 버퍼의 주소 값
 * @param nbytes: 전송할 데이터 크기를 바이트 단위로 전달
 * @param from: 발신지 정보를 채워 넣을 sockaddr 구조체 변수의 주소
 * @param addrlen: 매개변수 to로 전달된 주소 값의 구조체 변수 크기 
----------------------------------------------------------------

데이터의 경계가 존재하는 UDP 소켓
- TCP 기반에서 송수신하는 데이터에는 경계가 존재하지 않았다. 
  -> 데이터 송수신 과정에서 호출하는 입출력함수의 호출횟수는 큰 의미를 지니지 않는다.
- UDP는 데이터의 경계가 존재하는 프로토콜이다. (편지를 생각하면 쉬움)
  -> 데이터 송수신 과정에서 호출하는 입출력함수의 호출횟수가 중요하다.
  -> 입력함수의 호출횟수와 출력함수의 호출횟수가 완벽히 일치해야 송신된 데이터를 전부 수신할 수 있다. 
- 관련 실습 파일: bound_host1.c, bound_host2.c

UDP 데이터그램
- UDP 소켓이 전송하는 패킷을 가리켜 데이터그램이라고도 표현한다.
- TCP 패킷과 달리 데이터의 일부가 아닌 그 자체가 하나의 데이터로 의미를 가지므로 데이터그램이라고 표현할 수 있다.
- UDP는 데이터의 경계가 존재하기 때문에 하나의 패킷이 하나의 데이터로 간주될 수 있다.

connected UDP 소켓
- UDP 소켓은 기본적으로 unconnected이지만, 하나의 호스트와 오랜 시간 데이터를 송수신해야 한다면,
  connected UDP 소켓으로 만드는 것이 효율적이다.
- UDP 소켓을 대상으로 connect 함수만 호출해주면 된다.
- TCP 처럼 connect()를 호출했다고 해서 연결 설정이 되는 건 아니고, UDP 소켓의 목적지의 IP와 PORT정보가 등록될 뿐이다!
- connect() 이후에는 sendto(), recvfrom()이 아닌 write(), read()를 통해서도 데이터 송수신이 가능하다.
  sendto()도 그대로 쓸 수 있는데, 대신에 UDP 소켓에 목적지의 IP, PORT를 등록하거나 삭제하는 등의 과정이 생략된다.
- 관련 실습 파일: uecho_connect_client.c